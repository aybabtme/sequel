package generator

//go:generate embed file -var clientTemplate --source db_client.gotmpl
const clientTemplate = "package {{.Name}}\n\nimport (\n    \"database/sql\"\n    \"log\"\n    \"fmt\"\n\n    \"github.com/go-sql-driver/mysql\"\n)\n\nvar (\n    _ Querier = &sql.DB{}\n    _ Querier = &sql.Tx{}\n)\n\n// Querier is the interface implemented by types that can\ntype Querier interface {\n    Exec(query string, args ...interface{}) (sql.Result, error)\n    Prepare(query string) (*sql.Stmt, error)\n    Query(query string, args ...interface{}) (*sql.Rows, error)\n    QueryRow(query string, args ...interface{}) *sql.Row\n}\n\n\nvar (\n    _ RowScanner = &sql.Row{}\n    _ RowScanner = &sql.Rows{}\n)\n\ntype RowScanner interface {\n    Scan(dest ...interface{}) error\n}\n\nfunc isCommandOnTableDenied(err error) bool {\n    e, ok := err.(*mysql.MySQLError)\n    if !ok {\n        return false\n    }\n    return e.Number == 1142\n}\n\ntype Variables struct { {{range .Variables}}\n    {{.Name | camelize | export}} {{. | var_to_go_type}} {{end}}\n}\n\n{{$db := .Name | camelize | export}}\n\ntype {{$db}}DB struct {\n    Querier\n\n    Variables *Variables\n{{range .Tables}}{{$table := .Name | camelize | pluralize | export}}\n    {{$table}} *{{$table}}{{end}}\n}\n\nfunc New{{$db}}DB(querier Querier) (*{{$db}}DB, error) {\n    var err error\n    db := &{{$db}}DB{\n        Querier: querier,\n        Variables: Variables{ {{range .Variables}}\n    {{.Name | camelize | export}}: {{. | var_to_go_value}}, {{end}}\n        },\n    }\n\n    {{range .Tables}}\n    {{$table := .Name | camelize | pluralize | export}}\n    db.{{$table}}, err = new{{$table}}(db)\n    if err != nil {\n        return nil, err\n    }\n    {{end}}\n\n    return db, nil\n}\n\n\n{{range .Tables}}\n{{$table := .Name | camelize | pluralize | export}}\n{{$tbl := .}}\n\nconst (\n    create{{$table}}SQL   = {{. | createQuery}}\n\n    {{if .Pk}}retrieve{{$table}}SQL = {{. | retrieveQuery }}\n    {{end}}\n    update{{$table}}SQL   = {{. | updateQuery }}\n\n    delete{{$table}}SQL   = {{. | deleteQuery }}\n\n    list{{$table}}SQL     = {{. | listQuery }}\n\n    {{range .Indices}}{{$idxname := .KeyName | camelize | export}}\n    list{{$table}}Idx{{$idxname}}SQL = {{listIndex $tbl .}}\n    {{end}}\n)\n\n// {{$table}} provides operations on {{.Name | camelize | pluralize}} stored in {{$db}}.\ntype {{$table}} struct {\n    db   Querier\n    Name string\n\n\n    create   *sql.Stmt\n    retrieve *sql.Stmt\n    update   *sql.Stmt\n    delete   *sql.Stmt\n    list     *sql.Stmt\n\n    {{range .Indices}}{{$idxname := .KeyName | camelize | export}}\n    idx{{.KeyName | camelize | export}} *sql.Stmt{{end}}\n}\n\nfunc new{{$table}}(db Querier) (*{{$table}}, error) {\n    var err error\n    tbl := {{$table}}{db: db, Name: \"{{.Name}}\"}\n\n    bindings := []struct {\n        query string\n        stmt  **sql.Stmt\n    }{\n        {query: create{{$table}}SQL, stmt: &tbl.create},\n        {{if .Pk}}{query: retrieve{{$table}}SQL, stmt: &tbl.retrieve},{{end}}\n        {query: update{{$table}}SQL, stmt: &tbl.update},\n        {query: delete{{$table}}SQL, stmt: &tbl.delete},\n        {query: list{{$table}}SQL, stmt: &tbl.list},\n        // indices {{range .Indices}}{{$idxname := .KeyName | camelize | export}}\n        {query: list{{$table}}Idx{{$idxname}}SQL, stmt: &tbl.idx{{.KeyName | camelize | export}} }, {{end}}\n    }\n\n    for _, bind := range bindings {\n        (*bind.stmt), err = db.Prepare(bind.query)\n        switch {\n        case isCommandOnTableDenied(err):\n            log.Printf(\"unauthorized to perform query: %q\", bind.query)\n            return nil, nil // code trying to use this stmt should panic if they're not authorized\n        case err != nil:\n            return nil, fmt.Errorf(\"preparing query %q: %v\", bind.query, err)\n        }\n    }\n\n    return tbl, err\n}\n\n{{end}}\n"
