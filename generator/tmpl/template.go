package tmpl

//go:generate embed file -var ClientTemplate -source client.go.tmpl
//go:generate embed file -var CommonTemplate -source common.go.tmpl
//go:generate embed file -var TableTemplate -source table.go.tmpl

const (
	ClientTemplate = "package {{.Name}}\n\n{{$db_name := .Name | camelize | export}}\n\ntype {{$db_name}}DB struct {\n    Querier\n\n{{range .Tables}}{{$tbl_name := .Name | camelize | pluralize | export}}\n    {{$tbl_name}} *{{$tbl_name}}{{end}}\n}\n\nfunc New{{$db_name}}DB(querier Querier) (*{{$db_name}}DB, error) {\n    var err error\n    db := &{{$db_name}}DB{Querier: querier, }\n\n    {{range .Tables}}\n    {{$tbl_name := .Name | camelize | pluralize | export}}\n    db.{{$tbl_name}}, err = new{{$tbl_name}}(db)\n    if err != nil {\n        return nil, err\n    }\n    {{end}}\n\n    return db, nil\n}\n\n// Vars contains values set in a database.\nvar Vars = struct { {{range .Variables}}\n    {{.Name | camelize | export}} {{. | var_to_go_type}} {{end}}\n} { {{range .Variables}}\n    {{.Name | camelize | export}}: {{. | var_to_go_value}}, {{end}}\n}\n"
	CommonTemplate = "package {{.Name}}\n\nimport (\n    \"database/sql\"\n    \"database/sql/driver\"\n    \"encoding/json\"\n    \"time\"\n    \"bytes\"\n\n    \"github.com/go-sql-driver/mysql\"\n)\n\nvar (\n    _ Querier = &sql.DB{}\n    _ Querier = &sql.Tx{}\n)\n\n// Querier is the interface implemented by types that can\ntype Querier interface {\n    Exec(query string, args ...interface{}) (sql.Result, error)\n    Prepare(query string) (*sql.Stmt, error)\n    Query(query string, args ...interface{}) (*sql.Rows, error)\n    QueryRow(query string, args ...interface{}) *sql.Row\n}\n\nvar (\n    _ RowScanner = &sql.Row{}\n    _ RowScanner = &sql.Rows{}\n)\n\ntype RowScanner interface {\n    Scan(dest ...interface{}) error\n}\n\ntype Updater interface {\n    fields() []interface{}\n    cols() []string\n    FieldByColName(field string) (interface{}, error)\n}\n\n// Scan sets the columns named in cols into dst, using the data\n// in rs.\nfunc Scan(rs RowScanner, dst Updater, cols []string) error {\n    toScan := make([]interface{}, 0, len(cols))\n    for _, col := range cols {\n        field, err := dst.FieldByColName(col)\n        if err != nil {\n            return err\n        }\n        toScan = append(toScan, field)\n    }\n    return rs.Scan(toScan...)\n}\n\n\n// Null types\n\ntype NullInt64 sql.NullInt64\n\nvar (\n    _ json.Unmarshaler = &NullInt64{}\n    _ driver.Value     = &NullInt64{}\n)\n\nfunc NewInt64(i int64) NullInt64 {\n    return NullInt64{Int64: i, Valid: true}\n}\n\nfunc (n *NullInt64) Scan(value interface{}) error {\n    sqln := new(sql.NullInt64)\n    err := sqln.Scan(value)\n    *n = NullInt64(*sqln)\n    return err\n}\n\nfunc (n NullInt64) Value() (driver.Value, error) {\n    return sql.NullInt64(n).Value()\n}\n\nfunc (n *NullInt64) UnmarshalJSON(data []byte) error {\n    if bytes.Equal(data, []byte(\"null\")) {\n        n.Valid = false\n        return nil\n    }\n    err := json.Unmarshal(data, &n.Int64)\n    n.Valid = (err == nil)\n    return err\n}\n\nfunc (n NullInt64) MarshalJSON() ([]byte, error) {\n    if !n.Valid {\n        return []byte(\"null\"), nil\n    }\n    return json.Marshal(n.Int64)\n}\n\ntype NullString sql.NullString\n\nvar (\n    _ json.Unmarshaler = &NullString{}\n    _ driver.Value     = &NullString{}\n)\n\nfunc NewString(s string) NullString {\n    return NullString{String: s, Valid: true}\n}\n\nfunc (n *NullString) Scan(value interface{}) error {\n    sqln := new(sql.NullString)\n    err := sqln.Scan(value)\n    *n = NullString(*sqln)\n    return err\n}\n\nfunc (n NullString) Value() (driver.Value, error) {\n    return sql.NullString(n).Value()\n}\n\nfunc (n *NullString) UnmarshalJSON(data []byte) error {\n    if bytes.Equal(data, []byte(\"null\")) {\n        n.Valid = false\n        return nil\n    }\n    err := json.Unmarshal(data, &n.String)\n    n.Valid = (err == nil)\n    return err\n}\n\nfunc (n NullString) MarshalJSON() ([]byte, error) {\n    if !n.Valid {\n        return []byte(\"null\"), nil\n    }\n    return json.Marshal(n.String)\n}\n\ntype NullFloat64 sql.NullFloat64\n\nvar (\n    _ json.Unmarshaler = &NullFloat64{}\n    _ driver.Value     = &NullFloat64{}\n)\n\nfunc NewFloat64(f float64) NullFloat64 {\n    return NullFloat64{Float64: f, Valid: true}\n}\n\nfunc (n *NullFloat64) Scan(value interface{}) error {\n    sqln := new(sql.NullFloat64)\n    err := sqln.Scan(value)\n    *n = NullFloat64(*sqln)\n    return err\n}\n\nfunc (n NullFloat64) Value() (driver.Value, error) {\n    return sql.NullFloat64(n).Value()\n}\n\nfunc (n *NullFloat64) UnmarshalJSON(data []byte) error {\n    if bytes.Equal(data, []byte(\"null\")) {\n        n.Valid = false\n        return nil\n    }\n    err := json.Unmarshal(data, &n.Float64)\n    n.Valid = (err == nil)\n    return err\n}\n\nfunc (n NullFloat64) MarshalJSON() ([]byte, error) {\n    if !n.Valid {\n        return []byte(\"null\"), nil\n    }\n    return json.Marshal(n.Float64)\n}\n\ntype NullBool sql.NullBool\n\nvar (\n    _ json.Unmarshaler = &NullBool{}\n    _ driver.Value     = &NullBool{}\n)\n\nfunc NewBool(b bool) NullBool {\n    return NullBool{Bool: b, Valid: true}\n}\n\nfunc (n *NullBool) Scan(value interface{}) error {\n    sqln := new(sql.NullBool)\n    err := sqln.Scan(value)\n    *n = NullBool(*sqln)\n    return err\n}\n\nfunc (n NullBool) Value() (driver.Value, error) {\n    return sql.NullBool(n).Value()\n}\n\nfunc (n *NullBool) UnmarshalJSON(data []byte) error {\n    if bytes.Equal(data, []byte(\"null\")) {\n        n.Valid = false\n        return nil\n    }\n    err := json.Unmarshal(data, &n.Bool)\n    n.Valid = (err == nil)\n    return err\n}\n\nfunc (n NullBool) MarshalJSON() ([]byte, error) {\n    if !n.Valid {\n        return []byte(\"null\"), nil\n    }\n    return json.Marshal(n.Bool)\n}\n\ntype NullTime mysql.NullTime\n\nvar (\n    _ json.Unmarshaler = &NullTime{}\n    _ driver.Value     = &NullTime{}\n)\n\nfunc NewTime(t time.Time) NullTime {\n    return NullTime{Time: t, Valid: true}\n}\n\nfunc (n *NullTime) Scan(value interface{}) error {\n    sqln := new(mysql.NullTime)\n    err := sqln.Scan(value)\n    *n = NullTime(*sqln)\n    return err\n}\n\nfunc (n NullTime) Value() (driver.Value, error) {\n    return mysql.NullTime(n).Value()\n}\n\nfunc (n *NullTime) UnmarshalJSON(data []byte) error {\n    if bytes.Equal(data, []byte(\"null\")) {\n        n.Valid = false\n        return nil\n    }\n    err := json.Unmarshal(data, &n.Time)\n    n.Valid = (err == nil)\n    return err\n}\n\nfunc (n NullTime) MarshalJSON() ([]byte, error) {\n    if !n.Valid {\n        return []byte(\"null\"), nil\n    }\n    return json.Marshal(n.Time)\n}\n\nfunc isCommandOnTableDenied(err error) bool {\n    e, ok := err.(*mysql.MySQLError)\n    if !ok {\n        return false\n    }\n    return e.Number == 1142\n}\n"
	TableTemplate  = "package {{.DB.Name}}\n\nimport (\n    {{if .NeedsTime}}\"time\"{{end}}\n    \"database/sql\"\n    \"log\"\n    \"fmt\"\n)\n\n{{$db_name := .DB.Name | camelize | export}}\n{{$tbl := .Tbl}}\n{{$tbl_name := .Tbl.Name | camelize | pluralize | export}}\n{{$datatype :=  $tbl_name | singularize }}\n\nconst (\n    create{{$tbl_name}}SQL   = {{$tbl | createQuery}}\n\n    {{if $tbl.Pk}}retrieve{{$tbl_name}}SQL = {{$tbl | retrieveQuery }}\n    {{end}}\n    update{{$tbl_name}}SQL   = {{$tbl | updateQuery }}\n\n    delete{{$tbl_name}}SQL   = {{$tbl | deleteQuery }}\n\n    list{{$tbl_name}}SQL     = {{$tbl | listQuery }}\n\n    {{range $tbl.Indices}}{{$idxname := .KeyName | camelize | export}}\n    list{{$tbl_name}}Idx{{$idxname}}SQL = {{listIndex $tbl .}}\n    {{end}}\n)\n\n// {{$tbl_name}} provides operations on {{$datatype}}\n// stored in {{$db_name}}.\ntype {{$tbl_name}} struct {\n    db   Querier\n    Name string\n\n    create   *sql.Stmt\n    {{if $tbl.Pk}}retrieve *sql.Stmt {{end}}\n    update   *sql.Stmt\n    delete   *sql.Stmt\n    list     *sql.Stmt\n\n    {{range $tbl.Indices}}{{$idxname := .KeyName | camelize | export}}\n    idx{{.KeyName | camelize | export}} *sql.Stmt{{end}}\n}\n\nfunc new{{$tbl_name}}(db Querier) (*{{$tbl_name}}, error) {\n    var err error\n    tbl := &{{$tbl_name}}{db: db, Name: \"{{$tbl.Name}}\"}\n\n    bindings := []struct {\n        query string\n        stmt  **sql.Stmt\n    }{\n        {query: create{{$tbl_name}}SQL, stmt: &tbl.create},\n        {{if $tbl.Pk}}{query: retrieve{{$tbl_name}}SQL, stmt: &tbl.retrieve},{{end}}\n        {query: update{{$tbl_name}}SQL, stmt: &tbl.update},\n        {query: delete{{$tbl_name}}SQL, stmt: &tbl.delete},\n        {query: list{{$tbl_name}}SQL, stmt: &tbl.list},\n        // indices {{range $tbl.Indices}}{{$idxname := .KeyName | camelize | export}}\n        {query: list{{$tbl_name}}Idx{{$idxname}}SQL, stmt: &tbl.idx{{.KeyName | camelize | export}} }, {{end}}\n    }\n\n    for _, bind := range bindings {\n        (*bind.stmt), err = db.Prepare(bind.query)\n        switch {\n        case isCommandOnTableDenied(err):\n            log.Printf(\"unauthorized to perform query: %q\", bind.query)\n            return nil, nil // code trying to use this stmt should panic if they're not authorized\n        case err != nil:\n            return nil, fmt.Errorf(\"preparing query %q: %v\", bind.query, err)\n        }\n    }\n\n    return tbl, err\n}\n\n\n\n// {{$datatype}} represents a row in table {{$tbl_name}}.\ntype {{$datatype}} struct { {{range $tbl.Columns}}\n    {{.Name | camelize | export}} {{. | col_to_go_type}} {{end}}\n}\n\n// ensures that {{$datatype}} implements the Updater interface.\nvar _ Updater = &{{$datatype}}{}\n\nfunc (d {{$datatype}}) cols() []string {\n    return []string{ {{range .Columns}}\n        \"{{.Name}}\",{{end}}\n    }\n}\n\nfunc (d {{$datatype}}) fields() []interface{}{\n    return []interface{}{ {{range .Columns}}\n        &d.{{.Name | camelize | export}}, {{end}}\n    }\n}\n\n// FieldByColName returns the field in {{$datatype}} that represents the\n// column named `col`.\nfunc (d {{$datatype}}) FieldByColName(col string) (interface{}, error) {\n    switch col { {{range .Columns}}\n    case \"{{.Name}}\":\n        return &d.{{.Name | camelize | export}}, nil{{end}}\n    default:\n        return nil, fmt.Errorf(\"invalid column %q\", col)\n    }\n}\n\n\n{{if $tbl.Pk}}\n{{$pklen := len $tbl.Pk.Columns}}\n{{if eq $pklen 1}}\n{{$col := index $tbl.Pk.Columns 0}}\n{{$colname := $col.Name | camelize | export}}\n// Create a new {{$datatype}}.\nfunc (tbl *{{$tbl_name}}) Create(d *{{$datatype}}) error {\n\n    {{ $col := .HasUpdatedAt}}\n    {{if $col}}\n    {{if $col.Nullable}}\n    d.CreatedAt = NewTime(time.Now())\n    {{else}}\n    d.CreatedAt = time.Now().UTC().Truncate(time.Second)\n    {{end}}\n    {{end}}\n\n    // skip the ID\n    res, err := tbl.create.Exec(d.fields()[1:]...)\n    if err != nil {\n        return err\n    }\n\n    id, err := res.LastInsertId()\n    if err != nil {\n        return err\n    }\n\n    d.{{$colname}} = int(id)\n    return nil\n}\n\n// Retrieve an existing {{$datatype}} by ID.\nfunc (tbl *{{$tbl_name}}) Retrieve(id int64) (*{{$datatype}}, bool, error) {\n\n    rs, err := tbl.retrieve.Query(id)\n    switch err {\n    default:\n        return nil, false, err\n    case sql.ErrNoRows:\n        return nil, false, nil\n    case nil:\n        defer rs.Close()\n    }\n    if !rs.Next() {\n        return nil, false, nil\n    }\n    d := &{{$datatype}}{}\n    return d, true, Scan(rs, d, d.cols())\n}\n\n// Update an existing {{$datatype}} by ID.\nfunc (tbl *{{$tbl_name}}) Update(d *{{$datatype}}) error {\n    {{ $col := .HasUpdatedAt}}\n    {{if $col}}\n    {{if $col.Nullable}}\n    d.UpdatedAt = NewTime(time.Now())\n    {{else}}\n    d.UpdatedAt = time.Now().UTC().Truncate(time.Second)\n    {{end}}\n    {{end}}\n\n    _, err := tbl.update.Exec(append(d.fields()[1:], d.{{$colname}})...)\n    return err\n}\n\n// Delete an existing {{$datatype}} by ID.\nfunc (tbl *{{$tbl_name}}) Delete(d *{{$datatype}}) error {\n    _, err := tbl.delete.Exec(d.{{$colname}})\n    return err\n}\n{{else}}\n\n// Delete an existing {{$datatype}} by its fields (all fields must match).\nfunc (tbl *{{$tbl_name}}) Delete(d *{{$datatype}}) error {\n    _, err := tbl.delete.Exec(d.fields()...)\n    return err\n}\n{{end}}\n\n\n{{else}}\n\n// Create a new {{$datatype}}.\nfunc (tbl *{{$tbl_name}}) Create(d *{{$datatype}}) error {\n    {{if .HasCreatedAt}}\n    d.CreatedAt = NewTime(time.Now())\n    {{end}}\n    _, err := tbl.create.Exec(d.fields()...)\n    return err\n}\n\n// Update an existing {{$datatype}} by its fields (all fields must match).\nfunc (tbl *{{$tbl_name}}) Update(d *{{$datatype}}) error {\n    {{if .HasUpdatedAt}}\n    d.UpdatedAt = NewTime(time.Now())\n    {{end}}\n    _, err := tbl.update.Exec(d.fields()...)\n    return err\n}\n\n// Delete an existing {{$datatype}} by its fields (all fields must match).\nfunc (tbl *{{$tbl_name}}) Delete(d *{{$datatype}}) error {\n    _, err := tbl.delete.Exec(d.fields()...)\n    return err\n}\n\n{{end}}\n\n// List all {{$datatype}}s starting from an offset. Limited to 10k rows.\nfunc (tbl *{{$tbl_name}}) List(offset int) ([]{{$datatype}}, error) {\n    var list []{{$datatype}}\n\n    rows, err := tbl.list.Query(offset)\n    switch err {\n    default:\n        return nil, err\n    case sql.ErrNoRows:\n        return list, nil\n    case nil:\n        defer rows.Close()\n    }\n\n    for rows.Next() {\n        d := {{$datatype}}{}\n        if err := Scan(rows, &d, d.cols()); err != nil {\n            return list, err\n        }\n        list = append(list, d)\n    }\n\n    return list, rows.Err()\n}\n\n{{range $tbl.Indices}}{{$idxname := .KeyName | camelize | export}}\n// ListBy{{$idxname}} finds all {{$datatype}}s that match the query\n// on the index `{{.KeyName}}`, starting at `offset`, limited to 10k rows.\nfunc (tbl *{{$tbl_name}}) ListBy{{$idxname}}({{. | idx_list_args}}, offset int) ([]{{$datatype}}, error) {\n    var list []{{$datatype}}\n\n    rows, err := tbl.idx{{$idxname}}.Query({{. | idx_query_args}}, offset)\n    switch err {\n    default:\n        return nil, err\n    case sql.ErrNoRows:\n        return list, nil\n    case nil:\n        defer rows.Close()\n    }\n\n    for rows.Next() {\n        d := {{$datatype}}{}\n        if err := Scan(rows, &d, d.cols()); err != nil {\n            return list, err\n        }\n        list = append(list, d)\n    }\n\n    return list, rows.Err()\n}\n{{end}}\n"
)

//go:generate embed file -var ClientTestTemplate -source client_test.go.tmpl
//go:generate embed file -var CommonTestTemplate -source common_test.go.tmpl
//go:generate embed file -var TableTestTemplate -source table_test.go.tmpl

const (
	ClientTestTemplate = "package {{.Name}}\n"
	CommonTestTemplate = "package {{.Name}}\n\nimport (\n    \"encoding/json\"\n    \"reflect\"\n    \"testing\"\n    \"time\"\n)\n\nfunc TestNullString(t *testing.T) {\n    tests := []struct {\n        input NullString\n        json  string\n    }{\n        {\n            input: NullString{Valid: false, String: \"\"},\n            json:  \"null\",\n        },\n        {\n            input: NullString{Valid: true, String: \"\"},\n            json:  `\"\"`,\n        },\n        {\n            input: NullString{Valid: true, String: \"something\"},\n            json:  `\"something\"`,\n        },\n    }\n\n    for _, tt := range tests {\n        data, err := json.Marshal(tt.input)\n        if err != nil {\n            t.Fatalf(\"json.Marshal(%v): %v\", tt.input, err)\n        }\n        if string(data) != tt.json {\n            t.Fatalf(\"json.Marshal(%v)=%v, expect %v\", tt.input, string(data), tt.json)\n        }\n        got := NullString{}\n\n        err = json.Unmarshal([]byte(tt.json), &got)\n        if err != nil {\n            t.Fatalf(\"json.Unmarshal(%v, %v): %v\", tt.json, got, err)\n        }\n\n        if !reflect.DeepEqual(tt.input, got) {\n            t.Fatalf(\"want %v, got %v\", tt.input, got)\n        }\n    }\n}\n\nfunc TestNullInt64(t *testing.T) {\n    tests := []struct {\n        input NullInt64\n        json  string\n    }{\n        {\n            input: NullInt64{Valid: false, Int64: 0},\n            json:  \"null\",\n        },\n        {\n            input: NullInt64{Valid: true, Int64: 0},\n            json:  `0`,\n        },\n        {\n            input: NullInt64{Valid: true, Int64: 42},\n            json:  `42`,\n        },\n    }\n\n    for _, tt := range tests {\n        data, err := json.Marshal(tt.input)\n        if err != nil {\n            t.Fatalf(\"json.Marshal(%v): %v\", tt.input, err)\n        }\n        if string(data) != tt.json {\n            t.Fatalf(\"json.Marshal(%v)=%v, expect %v\", tt.input, string(data), tt.json)\n        }\n        got := NullInt64{}\n\n        err = json.Unmarshal([]byte(tt.json), &got)\n        if err != nil {\n            t.Fatalf(\"json.Unmarshal(%v, %v): %v\", tt.json, got, err)\n        }\n\n        if !reflect.DeepEqual(tt.input, got) {\n            t.Fatalf(\"want %v, got %v\", tt.input, got)\n        }\n    }\n}\n\nfunc TestNullFloat64(t *testing.T) {\n    tests := []struct {\n        input NullFloat64\n        json  string\n    }{\n        {\n            input: NullFloat64{Valid: false, Float64: 0},\n            json:  \"null\",\n        },\n        {\n            input: NullFloat64{Valid: true, Float64: 0},\n            json:  `0`,\n        },\n        {\n            input: NullFloat64{Valid: true, Float64: 42},\n            json:  `42`,\n        },\n        {\n            input: NullFloat64{Valid: true, Float64: 42.1},\n            json:  `42.1`,\n        },\n    }\n\n    for _, tt := range tests {\n        data, err := json.Marshal(tt.input)\n        if err != nil {\n            t.Fatalf(\"json.Marshal(%v): %v\", tt.input, err)\n        }\n        if string(data) != tt.json {\n            t.Fatalf(\"json.Marshal(%v)=%v, expect %v\", tt.input, string(data), tt.json)\n        }\n        got := NullFloat64{}\n\n        err = json.Unmarshal([]byte(tt.json), &got)\n        if err != nil {\n            t.Fatalf(\"json.Unmarshal(%v, %v): %v\", tt.json, got, err)\n        }\n\n        if !reflect.DeepEqual(tt.input, got) {\n            t.Fatalf(\"want %v, got %v\", tt.input, got)\n        }\n    }\n}\n\nfunc TestNullBool(t *testing.T) {\n    tests := []struct {\n        input NullBool\n        json  string\n    }{\n        {\n            input: NullBool{Valid: false, Bool: false},\n            json:  \"null\",\n        },\n        {\n            input: NullBool{Valid: true, Bool: true},\n            json:  `true`,\n        },\n        {\n            input: NullBool{Valid: true, Bool: false},\n            json:  `false`,\n        },\n    }\n\n    for _, tt := range tests {\n        data, err := json.Marshal(tt.input)\n        if err != nil {\n            t.Fatalf(\"json.Marshal(%v): %v\", tt.input, err)\n        }\n        if string(data) != tt.json {\n            t.Fatalf(\"json.Marshal(%v)=%v, expect %v\", tt.input, string(data), tt.json)\n        }\n        got := NullBool{}\n\n        err = json.Unmarshal([]byte(tt.json), &got)\n        if err != nil {\n            t.Fatalf(\"json.Unmarshal(%v, %v): %v\", tt.json, got, err)\n        }\n\n        if !reflect.DeepEqual(tt.input, got) {\n            t.Fatalf(\"want %v, got %v\", tt.input, got)\n        }\n    }\n}\n\nfunc TestNullTime(t *testing.T) {\n    tests := []struct {\n        input NullTime\n        json  string\n    }{\n        {\n            input: NullTime{Valid: false, Time: time.Time{}},\n            json:  \"null\",\n        },\n        {\n            input: NullTime{Valid: true, Time: time.Date(2000, 1, 1, 1, 1, 1, 1, time.UTC)},\n            json:  `\"2000-01-01T01:01:01.000000001Z\"`,\n        },\n    }\n\n    for _, tt := range tests {\n        data, err := json.Marshal(tt.input)\n        if err != nil {\n            t.Fatalf(\"json.Marshal(%v): %v\", tt.input, err)\n        }\n        if string(data) != tt.json {\n            t.Fatalf(\"json.Marshal(%v)=%v, expect %v\", tt.input, string(data), tt.json)\n        }\n        got := NullTime{}\n\n        err = json.Unmarshal([]byte(tt.json), &got)\n        if err != nil {\n            t.Fatalf(\"json.Unmarshal(%v, %v): %v\", tt.json, got, err)\n        }\n\n        if !reflect.DeepEqual(tt.input, got) {\n            t.Fatalf(\"want %v, got %v\", tt.input, got)\n        }\n    }\n}\n"
	TableTestTemplate  = "package {{.DB.Name}}\n\n"
)
