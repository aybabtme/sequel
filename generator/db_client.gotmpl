package {{.Name}}

import (
    "bytes"
    "database/sql"
    "database/sql/driver"
    "encoding/json"
    "fmt"
    "log"
    "time"

    "github.com/go-sql-driver/mysql"
)

var (
    _ Querier = &sql.DB{}
    _ Querier = &sql.Tx{}
)

// Querier is the interface implemented by types that can
type Querier interface {
    Exec(query string, args ...interface{}) (sql.Result, error)
    Prepare(query string) (*sql.Stmt, error)
    Query(query string, args ...interface{}) (*sql.Rows, error)
    QueryRow(query string, args ...interface{}) *sql.Row
}

var (
    _ RowScanner = &sql.Row{}
    _ RowScanner = &sql.Rows{}
)

type RowScanner interface {
    Scan(dest ...interface{}) error
}

type Updater interface {
    Fields() []interface{}
    FieldCols() []string
    FieldByCol(field string) (interface{}, error)
}

// Scan sets the columns named in cols into dst, using the data
// in rs.
func Scan(rs RowScanner, dst Updater, cols []string) error {
    toScan := make([]interface{}, 0, len(cols))
    for _, col := range cols {
        field, err := dst.FieldByColName(col)
        if err != nil {
            return err
        }
        toScan = append(toScan, field)
    }
    return rs.Scan(toScan...)
}


// Null types

type NullInt64 sql.NullInt64

var (
    _ json.Unmarshaler = &NullInt64{}
    _ driver.Value     = &NullInt64{}
)

func NewInt64(i int64) NullInt64 {
    return NullInt64{Int64: i, Valid: true}
}

func (n *NullInt64) Scan(value interface{}) error {
    sqln := new(sql.NullInt64)
    err := sqln.Scan(value)
    *n = NullInt64(*sqln)
    return err
}

func (n NullInt64) Value() (driver.Value, error) {
    return sql.NullInt64(n).Value()
}

func (n *NullInt64) UnmarshalJSON(data []byte) error {
    if bytes.Equal(data, []byte("null")) {
        n.Valid = false
        return nil
    }
    err := json.Unmarshal(data, &n.Int64)
    n.Valid = (err == nil)
    return err
}

func (n NullInt64) MarshalJSON() ([]byte, error) {
    if !n.Valid {
        return []byte("null"), nil
    }
    return json.Marshal(n.Int64)
}

type NullString sql.NullString

var (
    _ json.Unmarshaler = &NullString{}
    _ driver.Value     = &NullString{}
)

func NewString(s string) NullString {
    return NullString{String: s, Valid: true}
}

func (n *NullString) Scan(value interface{}) error {
    sqln := new(sql.NullString)
    err := sqln.Scan(value)
    *n = NullString(*sqln)
    return err
}

func (n NullString) Value() (driver.Value, error) {
    return sql.NullString(n).Value()
}

func (n *NullString) UnmarshalJSON(data []byte) error {
    if bytes.Equal(data, []byte("null")) {
        n.Valid = false
        return nil
    }
    err := json.Unmarshal(data, &n.String)
    n.Valid = (err == nil)
    return err
}

func (n NullString) MarshalJSON() ([]byte, error) {
    if !n.Valid {
        return []byte("null"), nil
    }
    return json.Marshal(n.String)
}

type NullFloat64 sql.NullFloat64

var (
    _ json.Unmarshaler = &NullFloat64{}
    _ driver.Value     = &NullFloat64{}
)

func NewFloat64(f float64) NullFloat64 {
    return NullFloat64{Float64: f, Valid: true}
}

func (n *NullFloat64) Scan(value interface{}) error {
    sqln := new(sql.NullFloat64)
    err := sqln.Scan(value)
    *n = NullFloat64(*sqln)
    return err
}

func (n NullFloat64) Value() (driver.Value, error) {
    return sql.NullFloat64(n).Value()
}

func (n *NullFloat64) UnmarshalJSON(data []byte) error {
    if bytes.Equal(data, []byte("null")) {
        n.Valid = false
        return nil
    }
    err := json.Unmarshal(data, &n.Float64)
    n.Valid = (err == nil)
    return err
}

func (n NullFloat64) MarshalJSON() ([]byte, error) {
    if !n.Valid {
        return []byte("null"), nil
    }
    return json.Marshal(n.Float64)
}

type NullBool sql.NullBool

var (
    _ json.Unmarshaler = &NullBool{}
    _ driver.Value     = &NullBool{}
)

func NewBool(b bool) NullBool {
    return NullBool{Bool: b, Valid: true}
}

func (n *NullBool) Scan(value interface{}) error {
    sqln := new(sql.NullBool)
    err := sqln.Scan(value)
    *n = NullBool(*sqln)
    return err
}

func (n NullBool) Value() (driver.Value, error) {
    return sql.NullBool(n).Value()
}

func (n *NullBool) UnmarshalJSON(data []byte) error {
    if bytes.Equal(data, []byte("null")) {
        n.Valid = false
        return nil
    }
    err := json.Unmarshal(data, &n.Bool)
    n.Valid = (err == nil)
    return err
}

func (n NullBool) MarshalJSON() ([]byte, error) {
    if !n.Valid {
        return []byte("null"), nil
    }
    return json.Marshal(n.Bool)
}

type NullTime mysql.NullTime

var (
    _ json.Unmarshaler = &NullTime{}
    _ driver.Value     = &NullTime{}
)

func NewTime(t time.Time) NullTime {
    return NullTime{Time: t, Valid: true}
}

func (n *NullTime) Scan(value interface{}) error {
    sqln := new(mysql.NullTime)
    err := sqln.Scan(value)
    *n = NullTime(*sqln)
    return err
}

func (n NullTime) Value() (driver.Value, error) {
    return mysql.NullTime(n).Value()
}

func (n *NullTime) UnmarshalJSON(data []byte) error {
    if bytes.Equal(data, []byte("null")) {
        n.Valid = false
        return nil
    }
    err := json.Unmarshal(data, &n.Time)
    n.Valid = (err == nil)
    return err
}

func (n NullTime) MarshalJSON() ([]byte, error) {
    if !n.Valid {
        return []byte("null"), nil
    }
    return json.Marshal(n.Time)
}



func isCommandOnTableDenied(err error) bool {
    e, ok := err.(*mysql.MySQLError)
    if !ok {
        return false
    }
    return e.Number == 1142
}

type Variables struct { {{range .Variables}}
    {{.Name | camelize | export}} {{. | var_to_go_type}} {{end}}
}

{{$db := .Name | camelize | export}}

type {{$db}}DB struct {
    Querier

    Variables *Variables
{{range .Tables}}{{$table := .Name | camelize | pluralize | export}}
    {{$table}} *{{$table}}{{end}}
}

func New{{$db}}DB(querier Querier) (*{{$db}}DB, error) {
    var err error
    db := &{{$db}}DB{
        Querier: querier,
        Variables: Variables{ {{range .Variables}}
    {{.Name | camelize | export}}: {{. | var_to_go_value}}, {{end}}
        },
    }

    {{range .Tables}}
    {{$table := .Name | camelize | pluralize | export}}
    db.{{$table}}, err = new{{$table}}(db)
    if err != nil {
        return nil, err
    }
    {{end}}

    return db, nil
}


{{range .Tables}}
{{$table := .Name | camelize | pluralize | export}}
{{$tbl := .}}

const (
    create{{$table}}SQL   = {{. | createQuery}}

    {{if .Pk}}retrieve{{$table}}SQL = {{. | retrieveQuery }}
    {{end}}
    update{{$table}}SQL   = {{. | updateQuery }}

    delete{{$table}}SQL   = {{. | deleteQuery }}

    list{{$table}}SQL     = {{. | listQuery }}

    {{range .Indices}}{{$idxname := .KeyName | camelize | export}}
    list{{$table}}Idx{{$idxname}}SQL = {{listIndex $tbl .}}
    {{end}}
)

// {{$table}} provides operations on {{.Name | camelize | pluralize}} stored in {{$db}}.
type {{$table}} struct {
    db   Querier
    Name string

    create   *sql.Stmt
    {{if .Pk}}retrieve *sql.Stmt {{end}}
    update   *sql.Stmt
    delete   *sql.Stmt
    list     *sql.Stmt

    {{range .Indices}}{{$idxname := .KeyName | camelize | export}}
    idx{{.KeyName | camelize | export}} *sql.Stmt{{end}}
}

func new{{$table}}(db Querier) (*{{$table}}, error) {
    var err error
    tbl := {{$table}}{db: db, Name: "{{.Name}}"}

    bindings := []struct {
        query string
        stmt  **sql.Stmt
    }{
        {query: create{{$table}}SQL, stmt: &tbl.create},
        {{if .Pk}}{query: retrieve{{$table}}SQL, stmt: &tbl.retrieve},{{end}}
        {query: update{{$table}}SQL, stmt: &tbl.update},
        {query: delete{{$table}}SQL, stmt: &tbl.delete},
        {query: list{{$table}}SQL, stmt: &tbl.list},
        // indices {{range .Indices}}{{$idxname := .KeyName | camelize | export}}
        {query: list{{$table}}Idx{{$idxname}}SQL, stmt: &tbl.idx{{.KeyName | camelize | export}} }, {{end}}
    }

    for _, bind := range bindings {
        (*bind.stmt), err = db.Prepare(bind.query)
        switch {
        case isCommandOnTableDenied(err):
            log.Printf("unauthorized to perform query: %q", bind.query)
            return nil, nil // code trying to use this stmt should panic if they're not authorized
        case err != nil:
            return nil, fmt.Errorf("preparing query %q: %v", bind.query, err)
        }
    }

    return tbl, err
}

{{$datatype :=  $table | singularize }}

type {{$datatype}} struct { {{range .Columns}}
    {{.Name | camelize | export}} {{. | col_to_go_type}} {{end}}
}

var _ Updater = &{{$datatype}}{}

func (d {{$datatype}}) cols() []interface{} {
    return []interface{}{ {{range .Columns}}
        &d.{{.Name | camelize | export}}, {{end}}
    }
}

func (d {{$datatype}}) fields() []string {
    return []string{ {{range .Columns}}
        "{{.Name}}",{{end}}
    }
}

func (d {{$datatype}}) FieldByColName(col string) (interface{}, error) {
    switch col { {{range .Columns}}
    case "{{.Name}}":
        return &d.{{.Name | camelize | export}}, nil{{end}}
    default:
        return nil, fmt.Errorf("invalid column %q", col)
    }
}


{{if .Pk}}
// Create a new {{$datatype}}.
func (tbl *{{$table}}) Create(d *{{$datatype}}) error {

    {{if .Has "created_at"}}
    d.CreatedAt = NewTime(time.Now())
    {{end}}

    // skip the ID
    res, err := tbl.create.Exec(d.fields()[1:]...)
    if err != nil {
        return err
    }

    id, err := res.LastInsertId()
    if err != nil {
        return err
    }

    d.ID = id
    return nil
}

// Retrieve an existing {{$datatype}} by ID.
func (tbl *{{$table}}) Retrieve(id int64) (*{{$datatype}}, bool, error) {

    rs, err := tbl.retrieve.Query(id)
    switch err {
    default:
        return nil, false, err
    case sql.ErrNoRows:
        return nil, false, nil
    case nil:
        defer rs.Close()
    }
    if !rs.Next() {
        return nil, false, nil
    }
    d := &{{$datatype}}{}
    return d, true, Scan(rs, d, d.cols())
}

// Update an existing {{$datatype}} by ID.
func (tbl *{{$table}}) Update(d *{{$datatype}}) error {
    {{if .Has "updated_at"}}
    d.UpdatedAt = NewTime(time.Now())
    {{end}}
    _, err := tbl.update.Exec(append(d.fields()[1:], d.ID)...)
    return err
}

// Delete an existing {{$datatype}} by ID.
func (tbl *{{$table}}) Delete(d *{{$datatype}}) error {
    _, err := tbl.delete.Exec(d.ID)
    return err
}

{{else}}

// Create a new {{$datatype}}.
func (tbl *{{$table}}) Create(d *{{$datatype}}) error {
    {{if .Has "created_at"}}
    d.CreatedAt = NewTime(time.Now())
    {{end}}
    _, err := tbl.create.Exec(d.fields()...)
    return err
}

// Update an existing {{$datatype}} by its fields (all fields must match)
func (tbl *{{$table}}) Update(d *{{$datatype}}) error {
    {{if .Has "updated_at"}}
    d.UpdatedAt = NewTime(time.Now())
    {{end}}
    _, err := tbl.update.Exec(d.fields()...)
    return err
}

// Delete an existing {{$datatype}} by its fields (all fields must match)
func (tbl *{{$table}}) Delete(d *{{$datatype}}) error {
    _, err := tbl.delete.Exec(d.fields()...)
    return err
}

{{end}}

// List all {{$datatype}}s starting from an offset. Limited to 10k rows.
func (tbl *{{$table}}) List(offset int) ([]{{$datatype}}, error) {
    var list []{{$datatype}}

    rows, err := tbl.list.Query(offset)
    switch err {
    default:
        return nil, err
    case sql.ErrNoRows:
        return list, nil
    case nil:
        defer rows.Close()
    }

    for rows.Next() {
        d := {{$datatype}}{}
        if err := Scan(rows, &d, d.cols()); err != nil {
            return list, err
        }
        list = append(list, d)
    }

    return list, rows.Err()
}

{{range .Indices}}{{$idxname := .KeyName | camelize | export}}
// ListBy{{$idxname}} finds all {{$datatype}}s that match the query
// pn the index `{{.KeyName}}`, starting at `offset`, limited to 10k rows.
func (tbl *{{$table}}) ListBy{{$idxname}}({{. | idx_list_args}}, offset int) ([]{{$datatype}}, error) {
    var list []{{$datatype}}

    rows, err := tbl.idx{{$idxname}}.Query({{. | idx_query_args}}, offset)
    switch err {
    default:
        return nil, err
    case sql.ErrNoRows:
        return list, nil
    case nil:
        defer rows.Close()
    }

    for rows.Next() {
        d := {{$datatype}}{}
        if err := Scan(rows, &d, d.cols()); err != nil {
            return list, err
        }
        list = append(list, d)
    }

    return list, rows.Err()
}
{{end}}

{{end}}
