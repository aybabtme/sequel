package {{.Name}}

import (
    "bytes"
    "database/sql"
    "database/sql/driver"
    "encoding/json"
    "fmt"
    "log"
    "time"

    "github.com/go-sql-driver/mysql"
)

var (
    _ Querier = &sql.DB{}
    _ Querier = &sql.Tx{}
)

// Querier is the interface implemented by types that can
type Querier interface {
    Exec(query string, args ...interface{}) (sql.Result, error)
    Prepare(query string) (*sql.Stmt, error)
    Query(query string, args ...interface{}) (*sql.Rows, error)
    QueryRow(query string, args ...interface{}) *sql.Row
}

var (
    _ RowScanner = &sql.Row{}
    _ RowScanner = &sql.Rows{}
)

type RowScanner interface {
    Scan(dest ...interface{}) error
}


type NullInt64 sql.NullInt64

var (
    _ json.Unmarshaler = &NullInt64{}
    _ driver.Value     = &NullInt64{}
)

func NewInt64(i int64) NullInt64 {
    return NullInt64{Int64: i, Valid: true}
}

func (n *NullInt64) Scan(value interface{}) error {
    sqln := new(sql.NullInt64)
    err := sqln.Scan(value)
    *n = NullInt64(*sqln)
    return err
}

func (n NullInt64) Value() (driver.Value, error) {
    return sql.NullInt64(n).Value()
}

func (n *NullInt64) UnmarshalJSON(data []byte) error {
    if bytes.Equal(data, []byte("null")) {
        n.Valid = false
        return nil
    }
    err := json.Unmarshal(data, &n.Int64)
    n.Valid = (err == nil)
    return err
}

func (n NullInt64) MarshalJSON() ([]byte, error) {
    if !n.Valid {
        return []byte("null"), nil
    }
    return json.Marshal(n.Int64)
}

type NullString sql.NullString

var (
    _ json.Unmarshaler = &NullString{}
    _ driver.Value     = &NullString{}
)

func NewString(s string) NullString {
    return NullString{String: s, Valid: true}
}

func (n *NullString) Scan(value interface{}) error {
    sqln := new(sql.NullString)
    err := sqln.Scan(value)
    *n = NullString(*sqln)
    return err
}

func (n NullString) Value() (driver.Value, error) {
    return sql.NullString(n).Value()
}

func (n *NullString) UnmarshalJSON(data []byte) error {
    if bytes.Equal(data, []byte("null")) {
        n.Valid = false
        return nil
    }
    err := json.Unmarshal(data, &n.String)
    n.Valid = (err == nil)
    return err
}

func (n NullString) MarshalJSON() ([]byte, error) {
    if !n.Valid {
        return []byte("null"), nil
    }
    return json.Marshal(n.String)
}

type NullFloat64 sql.NullFloat64

var (
    _ json.Unmarshaler = &NullFloat64{}
    _ driver.Value     = &NullFloat64{}
)

func NewFloat64(f float64) NullFloat64 {
    return NullFloat64{Float64: f, Valid: true}
}

func (n *NullFloat64) Scan(value interface{}) error {
    sqln := new(sql.NullFloat64)
    err := sqln.Scan(value)
    *n = NullFloat64(*sqln)
    return err
}

func (n NullFloat64) Value() (driver.Value, error) {
    return sql.NullFloat64(n).Value()
}

func (n *NullFloat64) UnmarshalJSON(data []byte) error {
    if bytes.Equal(data, []byte("null")) {
        n.Valid = false
        return nil
    }
    err := json.Unmarshal(data, &n.Float64)
    n.Valid = (err == nil)
    return err
}

func (n NullFloat64) MarshalJSON() ([]byte, error) {
    if !n.Valid {
        return []byte("null"), nil
    }
    return json.Marshal(n.Float64)
}

type NullBool sql.NullBool

var (
    _ json.Unmarshaler = &NullBool{}
    _ driver.Value     = &NullBool{}
)

func NewBool(b bool) NullBool {
    return NullBool{Bool: b, Valid: true}
}

func (n *NullBool) Scan(value interface{}) error {
    sqln := new(sql.NullBool)
    err := sqln.Scan(value)
    *n = NullBool(*sqln)
    return err
}

func (n NullBool) Value() (driver.Value, error) {
    return sql.NullBool(n).Value()
}

func (n *NullBool) UnmarshalJSON(data []byte) error {
    if bytes.Equal(data, []byte("null")) {
        n.Valid = false
        return nil
    }
    err := json.Unmarshal(data, &n.Bool)
    n.Valid = (err == nil)
    return err
}

func (n NullBool) MarshalJSON() ([]byte, error) {
    if !n.Valid {
        return []byte("null"), nil
    }
    return json.Marshal(n.Bool)
}

type NullTime mysql.NullTime

var (
    _ json.Unmarshaler = &NullTime{}
    _ driver.Value     = &NullTime{}
)

func NewTime(t time.Time) NullTime {
    return NullTime{Time: t, Valid: true}
}

func (n *NullTime) Scan(value interface{}) error {
    sqln := new(mysql.NullTime)
    err := sqln.Scan(value)
    *n = NullTime(*sqln)
    return err
}

func (n NullTime) Value() (driver.Value, error) {
    return mysql.NullTime(n).Value()
}

func (n *NullTime) UnmarshalJSON(data []byte) error {
    if bytes.Equal(data, []byte("null")) {
        n.Valid = false
        return nil
    }
    err := json.Unmarshal(data, &n.Time)
    n.Valid = (err == nil)
    return err
}

func (n NullTime) MarshalJSON() ([]byte, error) {
    if !n.Valid {
        return []byte("null"), nil
    }
    return json.Marshal(n.Time)
}



func isCommandOnTableDenied(err error) bool {
    e, ok := err.(*mysql.MySQLError)
    if !ok {
        return false
    }
    return e.Number == 1142
}

type Variables struct { {{range .Variables}}
    {{.Name | camelize | export}} {{. | var_to_go_type}} {{end}}
}

{{$db := .Name | camelize | export}}

type {{$db}}DB struct {
    Querier

    Variables *Variables
{{range .Tables}}{{$table := .Name | camelize | pluralize | export}}
    {{$table}} *{{$table}}{{end}}
}

func New{{$db}}DB(querier Querier) (*{{$db}}DB, error) {
    var err error
    db := &{{$db}}DB{
        Querier: querier,
        Variables: Variables{ {{range .Variables}}
    {{.Name | camelize | export}}: {{. | var_to_go_value}}, {{end}}
        },
    }

    {{range .Tables}}
    {{$table := .Name | camelize | pluralize | export}}
    db.{{$table}}, err = new{{$table}}(db)
    if err != nil {
        return nil, err
    }
    {{end}}

    return db, nil
}


{{range .Tables}}
{{$table := .Name | camelize | pluralize | export}}
{{$tbl := .}}

const (
    create{{$table}}SQL   = {{. | createQuery}}

    {{if .Pk}}retrieve{{$table}}SQL = {{. | retrieveQuery }}
    {{end}}
    update{{$table}}SQL   = {{. | updateQuery }}

    delete{{$table}}SQL   = {{. | deleteQuery }}

    list{{$table}}SQL     = {{. | listQuery }}

    {{range .Indices}}{{$idxname := .KeyName | camelize | export}}
    list{{$table}}Idx{{$idxname}}SQL = {{listIndex $tbl .}}
    {{end}}
)

// {{$table}} provides operations on {{.Name | camelize | pluralize}} stored in {{$db}}.
type {{$table}} struct {
    db   Querier
    Name string

    create   *sql.Stmt
    {{if .Pk}}retrieve *sql.Stmt {{end}}
    update   *sql.Stmt
    delete   *sql.Stmt
    list     *sql.Stmt

    {{range .Indices}}{{$idxname := .KeyName | camelize | export}}
    idx{{.KeyName | camelize | export}} *sql.Stmt{{end}}
}

func new{{$table}}(db Querier) (*{{$table}}, error) {
    var err error
    tbl := {{$table}}{db: db, Name: "{{.Name}}"}

    bindings := []struct {
        query string
        stmt  **sql.Stmt
    }{
        {query: create{{$table}}SQL, stmt: &tbl.create},
        {{if .Pk}}{query: retrieve{{$table}}SQL, stmt: &tbl.retrieve},{{end}}
        {query: update{{$table}}SQL, stmt: &tbl.update},
        {query: delete{{$table}}SQL, stmt: &tbl.delete},
        {query: list{{$table}}SQL, stmt: &tbl.list},
        // indices {{range .Indices}}{{$idxname := .KeyName | camelize | export}}
        {query: list{{$table}}Idx{{$idxname}}SQL, stmt: &tbl.idx{{.KeyName | camelize | export}} }, {{end}}
    }

    for _, bind := range bindings {
        (*bind.stmt), err = db.Prepare(bind.query)
        switch {
        case isCommandOnTableDenied(err):
            log.Printf("unauthorized to perform query: %q", bind.query)
            return nil, nil // code trying to use this stmt should panic if they're not authorized
        case err != nil:
            return nil, fmt.Errorf("preparing query %q: %v", bind.query, err)
        }
    }

    return tbl, err
}

{{$datatype :=  $table | singularize }}

type {{$datatype}} struct {
    {{range .Columns}}
    {{.Name | camelize | export}} {{. | col_to_go_type}} {{end}}
}

var _ sqldb.Updater = &{{$datatype}}{}

{{end}}
